import { Injectable } from "../dependency-injection/Injectable";
import { createDebugHandler } from "./debugHandler";
import { HandlerChainBuilder } from "./HandlerChainBuilder";
import { createNoCorsRetryingFetchHandler } from "./noCorsRetryingFetchHandler";
import { createRetryingHandler } from "./retryingHandler";
import { createTimeoutHandler } from "./timeoutHandler";
/**
 * The default Fetch implementation, used to make a simple HTTP requests without any custom headers. This can be passed
 * to `HandlerChainBuilder` to form the basis for other Fetch implementations (e.g. with custom headers, which extract
 * the Response body, etc.)
 *
 * Has support for retries, client-side timeout, and navigating federated auth flows that may not support CORs requests.
 *
 * @internal
 */
export const defaultFetchHandlerFactory = Injectable("defaultFetchHandler", () => {
    return (
    // Safety: We're re-typing fetch's second argument from `init?: RequestInit | undefined` to
    // `init: RequestInit | void` â€“ this is semantically equivalent, but the void makes for nicer ergonomics
    // elsewhere (e.g. so that callers can omit the second argument instead of being forced to pass undefined).
    new HandlerChainBuilder(fetch)
        .map(createDebugHandler())
        .map(createNoCorsRetryingFetchHandler())
        .map(createRetryingHandler())
        // TODO: completely arbitrary timeout -- this should be configurable by consumers, and we should think
        // about a sane default timeout UX... it's probably less than 10 seconds.
        .map(createTimeoutHandler({ timeout: 10 * 1000 })).handler);
});
//# sourceMappingURL=defaultFetchHandler.js.map