import { LensRepository } from "./lens/LensRepository";
import { Container } from "./dependency-injection/Container";
import { LensCoreModule } from "./lens-core-module/generated-types";
import { CameraKitSession } from "./session/CameraKitSession";
import { RootServices } from "./dependency-injection/RootServices";
import { MetricsEventTarget } from "./metrics/metricsEventTarget";
import { TypedEventTarget } from "./events/TypedEventTarget";
import { TypedCustomEvent } from "./events/TypedCustomEvent";
import { LensView } from "./metrics/reporters/reportLensView";
import { LensWait } from "./metrics/reporters/reportLensWait";
import { PageVisibility } from "./common/pageVisibility";
/**
 * Lens metrics events.
 *
 * These events are emitted by {@link CameraKit} to report lens usage, performance, apply latency, etc.
 *
 * @category Lenses
 * @category Metrics
 */
export type LensMetricsEvents = TypedCustomEvent<LensView["name"], LensView> | TypedCustomEvent<LensWait["name"], LensWait>;
/**
 * Options available when creating a {@link CameraKitSession}.
 *
 * @category Rendering
 */
export interface CreateSessionOptions {
    /**
     * Optionally provide an existing canvas element, on which the Live RenderTarget will be rendered.
     *
     * If this is not provided, CameraKit will create a new canvas element which can be added to the DOM.
     */
    liveRenderTarget?: HTMLCanvasElement;
    /**
     * Browsers optimize tabs when they are hidden - for example, by pausing the execution of requestAnimationFrame
     * callbacks.
     *
     * If you need the CameraKitSession to continue rendering even when the tab is in the background, set this to true.
     * There is a small performance penalty, and it's a good practice to only render in the background if absolutely
     * necessary.
     */
    renderWhileTabHidden?: boolean;
}
/**
 * The entry point to the CameraKit SDK's API. Most of CameraKit's features are accessed via this class.
 *
 * Applications obtain an instance of CameraKit by calling {@link bootstrapCameraKit}.
 *
 * @example
 * ```ts
 * const cameraKit = await bootstrapCameraKit(config)
 * ```
 *
 * Then this class can be used to:
 * - Create a {@link CameraKitSession} instance, which provides the API for setting up media inputs, applying Lenses,
 * and obtaining rendered `<canvas>` outputs.
 * - Query for lenses using {@link LensRepository}.
 * - Listen for lens usage metrics events using {@link MetricsEventTarget}.
 *
 * @category Rendering
 * @category Lenses
 */
export declare class CameraKit {
    /**
     * Used to query for lenses and lens groups.
     */
    readonly lensRepository: LensRepository;
    private readonly lensCore;
    private readonly pageVisibility;
    private readonly container;
    /** @deprecated Use {@link lensRepository} */
    readonly lenses: {
        repository: LensRepository;
    };
    /**
     * Business metrics (e.g. each time a lens is viewed) are emitted here.
     */
    readonly metrics: TypedEventTarget<LensMetricsEvents>;
    private sessions;
    /** @internal */
    constructor(
    /**
     * Used to query for lenses and lens groups.
     */
    lensRepository: LensRepository, lensCore: LensCoreModule, pageVisibility: PageVisibility, container: Container<RootServices>, allMetrics: MetricsEventTarget);
    /**
     * Create a CameraKitSession.
     *
     * This initializes the rendering engine and returns a {@link CameraKitSession} instance, which provides access
     * to Lens rendering.
     *
     * @example
     * ```ts
     * const cameraKit = await bootstrapCameraKit(config)
     * const session = await cameraKit.createSession()
     *
     * const lens = await cameraKit.lensRepository.loadLens(lensId, groupId)
     * session.applyLens(lens)
     * ```
     *
     * @param options
     */
    createSession({ liveRenderTarget, renderWhileTabHidden, }?: CreateSessionOptions): Promise<CameraKitSession>;
    /**
     * Destroys all sessions and frees all resources.
     */
    destroy(): Promise<void>;
}
/** @internal */
export declare const cameraKitFactory: {
    (args_0: LensRepository, args_1: MetricsEventTarget, args_2: LensCoreModule, args_3: PageVisibility, args_4: Container<{
        LensRepository: LensRepository;
    } & {
        metricsEventTarget: MetricsEventTarget;
    } & {
        lensCore: LensCoreModule;
    } & {
        pageVisibility: PageVisibility;
    } & {
        lensCore: LensCoreModule;
    } & import("./dependency-injection/RootServices").PublicServices & import("./dependency-injection/types").ServicesFromInjectables<[{
        (): MetricsEventTarget;
        token: "metricsEventTarget";
        dependencies: [];
    }, {
        (): import("./handlers/requestStateEmittingHandler").RequestStateEventTarget;
        token: "requestStateEventTarget";
        dependencies: [];
    }, {
        (args_0: import("./configuration").CameraKitConfiguration, args_1: import("./handlers").FetchHandler): import("./handlers/HandlerChainBuilder").Handler<RequestInfo, Response, RequestInit | undefined>;
        token: "cameraKitServiceFetchHandler";
        dependencies: readonly ["configuration", "defaultFetchHandler"];
    }, {
        (args_0: import("./configuration").CameraKitConfiguration, args_1: import("./handlers/requestStateEmittingHandler").RequestStateEventTarget, args_2: import("./metrics/operational/operationalMetricsReporter").OperationalMetricsReporter): import("./handlers/HandlerChainBuilder").Handler<Partial<import("./generated-proto/pb_schema/cdp/cof/config_request").ConfigTargetingRequest>, import("./generated-proto/pb_schema/cdp/cof/config_response").ConfigTargetingResponse, import("./remote-configuration/cofHandler").Metadata & {
            signal?: AbortSignal | null | undefined;
            isSideEffect?: boolean | undefined;
        }>;
        token: "cofHandler";
        dependencies: readonly ["configuration", "requestStateEventTarget", "operationalMetricsReporter"];
    }, {
        (args_0: import("./configuration").CameraKitConfiguration, args_1: import("./handlers/HandlerChainBuilder").Handler<Partial<import("./generated-proto/pb_schema/cdp/cof/config_request").ConfigTargetingRequest>, import("./generated-proto/pb_schema/cdp/cof/config_response").ConfigTargetingResponse, import("./remote-configuration/cofHandler").Metadata & {
            signal?: AbortSignal | null | undefined;
            isSideEffect?: boolean | undefined;
        }>, args_2: import("./handlers").FetchHandler): import("./remote-configuration/remoteConfiguration").RemoteConfiguration;
        token: "remoteConfiguration";
        dependencies: readonly ["configuration", "cofHandler", "cameraKitServiceFetchHandler"];
    }, {
        (args_0: import("./handlers/requestStateEmittingHandler").RequestStateEventTarget, args_1: import("./handlers").FetchHandler, args_2: import("./handlers").FetchHandler, args_3: import("./lens").LensSources, args_4: import("./lens").LensAssetRepository, args_5: import("./configuration").CameraKitConfiguration): LensRepository;
        token: "LensRepository";
        dependencies: readonly ["requestStateEventTarget", "cameraKitServiceFetchHandler", "defaultFetchHandler", "lensSources", "lensAssetRepository", "configuration"];
    }, {
        (args_0: LensCoreModule): import("./persistence/IndexedDBPersistence").IndexedDBPersistence<ArrayBuffer>;
        token: "lensPersistenceStore";
        dependencies: readonly ["lensCore"];
    }, {
        (args_0: import("./handlers").FetchHandler, args_1: PageVisibility): import("./handlers/HandlerChainBuilder").Handler<RequestInfo, Response, RequestInit | undefined>;
        token: "metricsHandler";
        dependencies: readonly ["cameraKitServiceFetchHandler", "pageVisibility"];
    }, {
        (args_0: import("./handlers").FetchHandler, args_1: PageVisibility, args_2: import("./configuration").CameraKitConfiguration): import("./metrics/operational/operationalMetricsReporter").OperationalMetricsReporter;
        token: "operationalMetricsReporter";
        dependencies: readonly ["metricsHandler", "pageVisibility", "configuration"];
    }, {
        (args_0: LensCoreModule, args_1: import("./lens").AssetLoader, args_2: import("./lens").AssetLoader, args_3: import("./lens").AssetLoader, args_4: MetricsEventTarget, args_5: import("./handlers/requestStateEmittingHandler").RequestStateEventTarget): import("./lens").LensAssetRepository;
        token: "lensAssetRepository";
        dependencies: readonly ["lensCore", "deviceDependentAssetLoader", "remoteMediaAssetLoader", "staticAssetLoader", "metricsEventTarget", "requestStateEventTarget"];
    }, {
        (args_0: import("./handlers").FetchHandler, args_1: import("./remote-configuration/remoteConfiguration").RemoteConfiguration): import("./lens").AssetLoader;
        token: "deviceDependentAssetLoader";
        dependencies: readonly ["defaultFetchHandler", "remoteConfiguration"];
    }, {
        (args_0: import("./handlers").FetchHandler): import("./lens").AssetLoader;
        token: "staticAssetLoader";
        dependencies: readonly ["defaultFetchHandler"];
    }, {
        (args_0: import("./remote-configuration/remoteConfiguration").RemoteConfiguration, args_1: import("./legal/legalPrompt").LegalPromptFactory): import("@snap/state-management").StateMachine<import("@snap/state-management").Action<"requestLegalPrompt", undefined> | import("@snap/state-management").Action<"accept", string> | import("@snap/state-management").Action<"reject", string>, import("@snap/state-management").State<"unknown", undefined> | import("@snap/state-management").State<"accepted", undefined> | import("@snap/state-management").State<"rejected", undefined>>;
        token: "legalState";
        dependencies: readonly ["remoteConfiguration", "legalPrompt"];
    }, {
        (): import("./legal/legalPrompt").LegalPromptFactory;
        token: "legalPrompt";
        dependencies: [];
    }, {
        (): import("rxjs").Observable<import("./logger/logger").LogEntry>;
        token: "logEntries";
        dependencies: [];
    }, {
        (args_0: import("rxjs").Observable<import("./logger/logger").LogEntry>, args_1: MetricsEventTarget, args_2: import("./metrics/operational/operationalMetricsReporter").OperationalMetricsReporter): import("./metrics/reporters/reportGlobalException").GlobalExceptionReporter;
        token: "reportGlobalException";
        dependencies: readonly ["logEntries", "metricsEventTarget", "operationalMetricsReporter"];
    }]>>): CameraKit;
    token: "CameraKit";
    dependencies: readonly ["LensRepository", "metricsEventTarget", "lensCore", "pageVisibility", "$container"];
};
