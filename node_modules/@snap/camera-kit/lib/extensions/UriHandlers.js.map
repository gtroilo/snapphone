{"version":3,"file":"UriHandlers.js","sourceRoot":"","sources":["../../src/extensions/UriHandlers.ts"],"names":[],"mappings":"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","sourcesContent":["import { isState } from \"@snap/state-management\";\nimport {\n    isArrayBuffer,\n    isArrayOfType,\n    isFunction,\n    isNumber,\n    isRecord,\n    isString,\n    isTypedArray,\n    isUndefined,\n    predicateRecordValues,\n} from \"../common/typeguards\";\nimport { Injectable } from \"../dependency-injection/Injectable\";\nimport { lensCoreFactory } from \"../lens-core-module\";\nimport { LensCoreModule, Uri, UriCancelRequest, UriRequest, UriResponse } from \"../lens-core-module/generated-types\";\nimport { Lens } from \"../lens/Lens\";\nimport { getLogger } from \"../logger/logger\";\nimport { LensKeyboard, lensKeyboardFactory } from \"../session/LensKeyboard\";\nimport { LensState, lensStateFactory } from \"../session/lensState\";\n\nconst logger = getLogger(\"UriHandlers\");\n\nconst SEPARATOR = \"://\";\n\nfunction extractSchemeAndRoute(uri: Uri) {\n    const separatorIndex = uri.indexOf(SEPARATOR);\n    const scheme = uri.slice(0, separatorIndex);\n    const route = uri.slice(separatorIndex + SEPARATOR.length);\n    return [scheme, route];\n}\n\nfunction isUri(value: unknown): value is Uri {\n    return isString(value) && value.includes(SEPARATOR);\n}\n\nfunction isUriHandler(value: unknown): value is UriHandler {\n    return (\n        isRecord(value) &&\n        (isUri(value.uri) || isArrayOfType(isUri, value.uri)) &&\n        isFunction(value.handleRequest) &&\n        (isUndefined(value.cancelRequest) || isFunction(value.cancelRequest))\n    );\n}\n\nfunction isUriHandlers(value: unknown): value is UriHandlers {\n    return isArrayOfType(isUriHandler, value);\n}\n\nfunction isUriResponse(value: unknown): value is UriResponse {\n    return (\n        isRecord(value) &&\n        isNumber(value.code) &&\n        isString(value.description) &&\n        isString(value.contentType) &&\n        (isArrayBuffer(value.data) || isTypedArray(value.data)) &&\n        (isUndefined(value.metadata) || predicateRecordValues(isString)(value.metadata))\n    );\n}\n\n/**\n * Provides a way for a lens to call into external services that work under HTTP-like protocol.\n */\nexport interface UriHandler {\n    /**\n     * [scheme]://[route] pattern that this handler processes or an array of patterns.\n     */\n    uri: Uri | Uri[];\n\n    /**\n     * Called to process the provided request.\n     * @param request Lens request.\n     * @param reply A callback function to send response back.\n     * The function can be called none or multiple number of times.\n     * @param lens Lens the request is coming from.\n     */\n    handleRequest(request: UriRequest, reply: (response: UriResponse) => void, lens: Lens): void;\n\n    /**\n     * Called to indicated that URI request initated earlier is cancelled.\n     * @param request Lens request.\n     * @param lens Lens the request is coming from.\n     */\n    cancelRequest?(request: UriCancelRequest, lens: Lens): void;\n}\n\n/**\n * Array of {@link UriHandler} objects.\n */\nexport type UriHandlers = UriHandler[];\n\n/**\n * An extension point for client URI handlers.\n */\nexport const uriHandlersFactory = Injectable(\"UriHandlers\", () => {\n    const uriHandlers: UriHandlers = [];\n    return uriHandlers;\n});\n\n/**\n * Registers URI handlers within LensCore.\n * @internal\n */\nexport const registerUriHandlers = Injectable(\n    \"registerUriHandlers\",\n    [lensCoreFactory.token, lensStateFactory.token, uriHandlersFactory.token, lensKeyboardFactory.token] as const,\n    (lensCore: LensCoreModule, lensState: LensState, userHandlers: UriHandlers, lensKeyboard: LensKeyboard): void => {\n        if (!isUriHandlers(userHandlers)) {\n            throw new Error(\"Expected an array of UriHandler objects\");\n        }\n\n        // Users may define UriHandlers using the uriHandlersFactory.token, but we need to add some internally-defined\n        // handlers (e.g. lens keyboard handler) before registering handlers with LensCore.\n        const allHandlers = userHandlers.concat(lensKeyboard.uriHandler);\n\n        for (const { uri, handleRequest, cancelRequest } of allHandlers) {\n            const uris = Array.isArray(uri) ? uri : [uri];\n            for (const [scheme, route] of uris.map(extractSchemeAndRoute)) {\n                lensCore.registerUriListener(scheme, route, {\n                    handleRequest: (request) => {\n                        const reply = (response: UriResponse) => {\n                            if (!isUriResponse(response)) {\n                                throw new Error(\"Expected UriResponse object\");\n                            }\n                            lensCore.provideUriResponse(request.identifier, response);\n                        };\n\n                        // Since lenses are the only things that make URI requests, we expect to always be in the\n                        // \"lensApplied\" state â€“ we'll sanity check, though, and log a warning if we're not.\n                        const state = lensState.getState();\n                        if (isState(state, \"noLensApplied\")) {\n                            logger.warn(\n                                `Got a URI request for ${request.uri}, but there is no active lens. The ` +\n                                    `request will not be processed.`\n                            );\n                            return;\n                        }\n\n                        // NOTE: we do not handle any error thrown on an extension side when handleRequest() is called.\n                        // That responsibility is delegated to the extension by design and that is exactly what Android\n                        // and iOS SDKs do.\n                        handleRequest(request, reply, state.data);\n                    },\n                    cancelRequest: (request) => {\n                        if (cancelRequest) {\n                            const state = lensState.getState();\n                            if (isState(state, \"noLensApplied\")) {\n                                logger.warn(\n                                    `Got a URI cancel request for ${request.uri}, but there is no active ` +\n                                        `lens. The cancel request will not be processed.`\n                                );\n                                return;\n                            }\n                            cancelRequest(request, state.data);\n                        }\n                    },\n                });\n            }\n        }\n    }\n);\n\nexport { Uri, UriCancelRequest, UriRequest, UriResponse } from \"../lens-core-module/generated-types\";\n"]}