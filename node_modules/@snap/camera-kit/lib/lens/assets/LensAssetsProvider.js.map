{"version":3,"file":"LensAssetsProvider.js","sourceRoot":"","sources":["../../../src/lens/assets/LensAssetsProvider.ts"],"names":[],"mappings":";AAAA,OAAO,EAAE,UAAU,EAAE,MAAM,uCAAuC,CAAC;AACnE,OAAO,EAAE,cAAc,EAAE,MAAM,mBAAmB,CAAC;AACnD,OAAO,EAAE,eAAe,EAAkB,MAAM,wBAAwB,CAAC;AACzE,OAAO,EAAE,SAAS,EAAE,MAAM,qBAAqB,CAAC;AAEhD,OAAO,EAAE,YAAY,EAAE,MAAM,SAAS,CAAC;AACvC,OAAO,EAAkB,qBAAqB,EAAE,MAAM,mBAAmB,CAAC;AAC1E,OAAO,EAAuB,0BAA0B,EAAE,MAAM,uBAAuB,CAAC;AAExF,MAAM,MAAM,GAAG,SAAS,CAAC,mBAAmB,CAAC,CAAC;AAC9C,MAAM,oBAAoB,GAAG,CAAC,CAAC;AAO/B;;;;;;;GAOG;AACH,MAAM,CAAC,MAAM,0BAA0B,GAAG,UAAU,CAChD,4BAA4B,EAC5B,CAAC,eAAe,CAAC,KAAK,EAAE,qBAAqB,CAAC,KAAK,EAAE,0BAA0B,CAAC,KAAK,CAAU,EAC/F,CAAC,QAAwB,EAAE,cAA8B,EAAE,mBAAwC,EAAE,EAAE;IACnG,MAAM,yBAAyB,GAAG,IAAI,GAAG,EAAkB,CAAC;IAE5D,QAAQ,CAAC,uBAAuB,CAAC,CAAO,eAAe,EAAE,EAAE;;QACvD,0FAA0F;QAC1F,sFAAsF;QACtF,uDAAuD;QACvD,MAAM,EAAE,OAAO,EAAE,SAAS,EAAE,QAAQ,EAAE,GAAG,eAAe,CAAC;QAEzD,IAAI;YACA,IAAI,CAAC,MAAA,yBAAyB,CAAC,GAAG,CAAC,OAAO,CAAC,mCAAI,CAAC,CAAC,GAAG,oBAAoB,EAAE;gBACtE,MAAM,IAAI,KAAK,CAAC,2DAA2D,OAAO,EAAE,CAAC,CAAC;aACzF;YAED,MAAM,IAAI,GAAG,QAAQ,CAAC,CAAC,CAAC,cAAc,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC;YAC7E,MAAM,mBAAmB,CAAC,SAAS,CAC/B,eAAe,EACf,IAAI,IAAI,YAAY,CAAC,IAAI,CAAC,EAC1B,MAAA,IAAI,aAAJ,IAAI,uBAAJ,IAAI,CAAE,OAAO,0CAAE,aAAa,CAC/B,CAAC;YACF,yBAAyB,CAAC,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC;SAC7C;QAAC,OAAO,KAAK,EAAE;YACZ,gEAAgE;YAChE,yFAAyF;YACzF,kGAAkG;YAClG,QAAQ,CAAC,2BAA2B,CAAC;gBACjC,OAAO;gBACP,SAAS;aACZ,CAAC,CAAC;YAEH,MAAM,iBAAiB,GAAG,CAAC,MAAA,yBAAyB,CAAC,GAAG,CAAC,OAAO,CAAC,mCAAI,CAAC,CAAC,GAAG,CAAC,CAAC;YAC5E,yBAAyB,CAAC,GAAG,CAAC,OAAO,EAAE,iBAAiB,CAAC,CAAC;YAE1D,gGAAgG;YAChG,6BAA6B;YAC7B,IAAI,iBAAiB,IAAI,oBAAoB,EAAE;gBAC3C,MAAM,CAAC,KAAK,CAAC,cAAc,CAAC,4CAA4C,OAAO,WAAW,EAAE,KAAK,CAAC,CAAC,CAAC;aACvG;iBAAM;gBACH,MAAM,CAAC,IAAI,CAAC,2DAA2D,OAAO,EAAE,CAAC,CAAC;aACrF;SACJ;IACL,CAAC,CAAA,CAAC,CAAC;AACP,CAAC,CACJ,CAAC","sourcesContent":["import { Injectable } from \"../../dependency-injection/Injectable\";\nimport { lensAssetError } from \"../../namedErrors\";\nimport { lensCoreFactory, LensCoreModule } from \"../../lens-core-module\";\nimport { getLogger } from \"../../logger/logger\";\nimport { MakeTaggedBusinessEvent } from \"../../metrics/businessEventsReporter\";\nimport { toPublicLens } from \"../Lens\";\nimport { LensRepository, lensRepositoryFactory } from \"../LensRepository\";\nimport { LensAssetRepository, lensAssetRepositoryFactory } from \"./LensAssetRepository\";\n\nconst logger = getLogger(\"LensAssetProvider\");\nconst maxConsecutiveErrors = 3;\n\n/**\n * The AssetValidationFailed metric reports every time we handle an asset checksum validation failure.\n */\nexport type AssetValidationFailed = MakeTaggedBusinessEvent<\"assetValidationFailed\">;\n\n/**\n * Registers a remote asset provider function with a given instance of LensCore.\n *\n * *Note:* LensCoreModule.initialize must be called on the desired LensCoreModule instance **prior** to passing it\n * to the LensAssetsProvider constructor. If this class is instantiated with a LensCoreModule that has not been\n * initialized, the registry of the asset provider function will fail silently and no remote assets will be loaded.\n * @internal\n */\nexport const registerLensAssetsProvider = Injectable(\n    \"registerLensAssetsProvider\",\n    [lensCoreFactory.token, lensRepositoryFactory.token, lensAssetRepositoryFactory.token] as const,\n    (lensCore: LensCoreModule, lensRepository: LensRepository, lensAssetRepository: LensAssetRepository) => {\n        const consecutiveErrorsPerAsset = new Map<string, number>();\n\n        lensCore.setRemoteAssetsProvider(async (assetDescriptor) => {\n            // Fetch an asset and provide it to LensCore. If fetching the asset fails we give LensCore\n            // an empty response (which it may handle in a variety of ways, e.g. retry, gracefully\n            // degrade lens behavior, throw error) and then reject.\n            const { assetId, assetType, effectId } = assetDescriptor;\n\n            try {\n                if ((consecutiveErrorsPerAsset.get(assetId) ?? 0) > maxConsecutiveErrors) {\n                    throw new Error(`Maximum consecutive asset load errors reached for asset ${assetId}`);\n                }\n\n                const lens = effectId ? lensRepository.getLensMetadata(effectId) : undefined;\n                await lensAssetRepository.loadAsset(\n                    assetDescriptor,\n                    lens && toPublicLens(lens),\n                    lens?.content?.assetManifest\n                );\n                consecutiveErrorsPerAsset.set(assetId, 0);\n            } catch (error) {\n                // if an error occurs, LensCore handles things in different ways\n                // depending on the active lens. It might: 1) retry, 2) gracefully degrade lens behavior,\n                // 3) lens JS might throw, which will be passed to the exceptionHandler we register with LensCore.\n                lensCore.provideRemoteAssetsResponse({\n                    assetId,\n                    assetType,\n                });\n\n                const consecutiveErrors = (consecutiveErrorsPerAsset.get(assetId) ?? 0) + 1;\n                consecutiveErrorsPerAsset.set(assetId, consecutiveErrors);\n\n                // We've already reported `maxConsecutiveErrors` number of errors for this asset, so we can skip\n                // logging additional errors.\n                if (consecutiveErrors <= maxConsecutiveErrors) {\n                    logger.error(lensAssetError(`Error occurred while handling lens asset ${assetId} request.`, error));\n                } else {\n                    logger.warn(`Maximum consecutive asset load errors reached for asset ${assetId}`);\n                }\n            }\n        });\n    }\n);\n"]}