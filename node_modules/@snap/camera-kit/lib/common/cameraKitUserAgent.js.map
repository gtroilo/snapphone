{"version":3,"file":"cameraKitUserAgent.js","sourceRoot":"","sources":["../../src/common/cameraKitUserAgent.ts"],"names":[],"mappings":"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","sourcesContent":["import environment from \"../environment.json\";\nimport lensCoreWasm from \"../lensCoreWasmVersions.json\";\nimport { locale } from \"./locale\";\nimport { isRecord } from \"./typeguards\";\n\ntype BrandArray = Array<{ brand: string; version: string }>;\n\ninterface NavigatorUAData {\n    brands: BrandArray;\n    mobile: boolean;\n    platform: string;\n}\n\ndeclare global {\n    interface Navigator {\n        userAgentData?: NavigatorUAData;\n    }\n}\n\n/**\n * Some user agents may not properly implement the NavigatorUAData interface, so we have to do our own validation here\n * to make sure we're dealing with a well-formed value.\n */\nfunction isNavigatorUAData(value: unknown): value is NavigatorUAData {\n    return (\n        isRecord(value) &&\n        Array.isArray(value[\"brands\"]) &&\n        value[\"brands\"].every((brand) => {\n            return isRecord(brand) && typeof brand[\"brand\"] === \"string\" && typeof brand[\"version\"] === \"string\";\n        }) &&\n        typeof value[\"mobile\"] === \"boolean\" &&\n        typeof value[\"platform\"] === \"string\"\n    );\n}\n\n/**\n * Parse the platform (i.e. OS) version.\n *\n * From limited testing, this seems to often produce incorrect results – the userAgent string does not typically include\n * the actual OS version.\n *\n * Better results could be obtained from [NavigatorUAData.getHighEntropyValues]\n * (https://developer.mozilla.org/en-US/docs/Web/API/NavigatorUAData/getHighEntropyValues), but this presents two\n * problems: 1) it's currently only supported on Chrome and 2) browsers may prompt the user for permission to share\n * this information.\n *\n * So, at least for now, we'll be satisfied with the incorrect version number.\n */\nfunction parsePlatformVersion(userAgent: string) {\n    // possible platform version values inside of user agent string\n    // \" 11;\"\n    // \" 10_15_7)\"\n    // \" 13_5_1 \"\n    // \" 10.0;\"\n    // \" 15_1 \"\n    const versionMatch = userAgent.match(/\\s([\\d][\\d_.]*[\\d])(;|\\)|\\s)/);\n\n    if (versionMatch != null) {\n        return versionMatch[1].replace(/_/g, \".\");\n    }\n\n    return \"\";\n}\n\n/**\n * In the future, we may invest in more robust device-detection (e.g. a UA string database), but for now this will give\n * us some sense of device usage.\n */\nfunction parseDeviceModel(userAgent: string) {\n    // from user agent like \"(Linux; Android 11; Pixel 2)\" extact \"Pixel 2\"\n    const userAgentWithModel = userAgent.match(/;[^;]+?;([^\\)]+?)\\)/);\n\n    if (userAgentWithModel) {\n        return userAgentWithModel[1].trim();\n    }\n\n    // from user agent like \"... (iPad; CPU OS 15_1 like Mac OS X) ...\" extract \"IPad\"\n    const userAgentWithModel2 = userAgent.match(/\\(([^;]+);/);\n\n    if (userAgentWithModel2) {\n        return userAgentWithModel2[1].trim();\n    }\n\n    return \"unknown\";\n}\n\n/**\n * Some browsers (e.g. Safari) do not support the `Navigator.userAgentData` API. We'll attempt a sort of polyfill by\n * parsing the data found in [NavigatorUAData](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorUAData) from\n * the raw user agent string.\n */\nfunction parseUserAgentData(userAgent: string): NavigatorUAData {\n    let brand: BrandArray[number];\n\n    // Parse UA string for Chromium-based browsers (e.g. Chrome, Edge)\n    if (/Chrome/.test(userAgent)) {\n        const versionMatch = userAgent.match(/Chrome\\/([\\d.]+)/);\n        brand = {\n            brand: \"Chrome\",\n            version: versionMatch !== null ? versionMatch[1] : \"unknown\",\n        };\n    }\n\n    // Parse UA string for Safari (very important for this to only be done if Chrome is not found – Chrome userAgent\n    // strings will contain \"Safari\")\n    else if (/Safari/.test(userAgent)) {\n        let versionMatch = userAgent.match(/Version\\/([\\d.]+)/);\n        if (versionMatch === null) versionMatch = userAgent.match(/Safari\\/([\\d.]+)/);\n        brand = {\n            brand: \"Safari\",\n            version: versionMatch !== null ? versionMatch[1] : \"unknown\",\n        };\n    }\n\n    // Parse UA for unknown browser.\n    // TODO: will be changed, default value support should be added on a COF server side.\n    else {\n        brand = {\n            brand: \"Firefox\",\n            version: \"0\",\n        };\n    }\n\n    // We're not using `mobile` for anything, and we have no consistent way to determine this from the UA string.\n    // We'll set it to false, but this should not be used – instead, we'll need to rely on more sophisticated methods\n    // (e.g. a userAgent database) to determine actual device.\n    const mobile = false;\n    const platform = parsePlaftformName(userAgent);\n\n    return {\n        brands: [brand],\n        mobile,\n        platform,\n    };\n}\n\n/* eslint-disable max-len */\n/**\n * The `brands` array found in [NavigatorUAData](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorUAData) is\n * intentionally designed to discourage standardized processing. This method of extracting brand information will be\n * inherently brittle, and it relies on us matching some well-known brands.\n *\n * For more detail from the spec:\n * See https://wicg.github.io/ua-client-hints/#monkeypatch-html-windoworworkerglobalscope\n * And https://wicg.github.io/ua-client-hints/#grease\n *\n * We also must match the list of known brands allowed by the backend, defined here:\n * https://github.sc-corp.net/Snapchat/useragent/blob/9333afe7cc6ac00503ad46cb234bcf94006dff98/java/useragent/src/main/java/snapchat/client/UserAgent.java#L124\n */\n/* eslint-enable */\ntype KnownBrand = \"Chrome\" | \"Safari\" | \"Firefox\";\nfunction normalizeBrands(brands: BrandArray): BrandArray {\n    const knownBrands = new Map<string, KnownBrand>([\n        [\"Chrome\", \"Chrome\"],\n        [\"Chromium\", \"Chrome\"],\n        [\"Firefox\", \"Firefox\"],\n        [\"Microsoft Edge\", \"Chrome\"],\n        [\"Safari\", \"Safari\"],\n    ]);\n\n    const normalizedBrands = brands\n        .filter(({ brand }) => knownBrands.has(brand))\n        .map((brand) => {\n            return {\n                // Safety: we've filtered out brands which do not appear as keys in `knownBrands`, so this cannot return\n                // undefined.\n                brand: knownBrands.get(brand.brand)!,\n                version: brand.version,\n            };\n        });\n\n    // TODO: default \"unknown\" value should be added on COF server side. For now we'll use Firefox.\n    if (normalizedBrands.length === 0) return [{ brand: \"Firefox\", version: \"0\" }];\n    return normalizedBrands;\n}\n\n/* eslint-disable max-len */\n/**\n * We must ensure the data we get from `navigator.userAgentData` is normalized to match what our backend expects to\n * see in our custom CameraKitWeb userAgent string.\n *\n * This string is defined here:\n * https://github.sc-corp.net/Snapchat/useragent/blob/9333afe7cc6ac00503ad46cb234bcf94006dff98/java/useragent/src/main/java/snapchat/client/UserAgent.java#L124\n */\n/* eslint-enable */\nfunction normalizeUserAgentData(userAgentData: NavigatorUAData): NavigatorUAData {\n    return {\n        brands: normalizeBrands(userAgentData.brands),\n        mobile: userAgentData.mobile,\n        platform: parsePlaftformName(userAgentData.platform),\n    };\n}\n\n/* eslint-disable max-len */\n/**\n * The backend defines the allowed list of known platforms which will pass their RegEx test when found in our custom\n * CameraKitWeb userAgent string.\n *\n * See https://github.sc-corp.net/Snapchat/useragent/blob/9333afe7cc6ac00503ad46cb234bcf94006dff98/java/useragent/src/main/java/snapchat/client/UserAgent.java#L124\n */\n/* eslint-enable */\ntype KnownPlatform = \"macos\" | \"windows\" | \"linux\" | \"android\" | \"ios\" | \"ipados\" | \"unknown\";\nfunction parsePlaftformName(userAgent: string): KnownPlatform {\n    const knownPlatforms = new Map<string, KnownPlatform>([\n        [\"android\", \"android\"],\n        [\"linux\", \"linux\"],\n        [\"iphone os\", \"ios\"],\n        [\"ipad\", \"ipados\"],\n        [\"mac os\", \"macos\"],\n        [\"macos\", \"macos\"],\n        [\"windows\", \"windows\"],\n    ]);\n\n    const normalizedUserAgent = userAgent.toLowerCase();\n    for (const [match, platform] of knownPlatforms.entries()) {\n        if (normalizedUserAgent.includes(match)) return platform;\n    }\n    return \"unknown\";\n}\n\n/**\n * We'll use the application's origin as an identifier – this isn't used for any kind of authentication, but it may be\n * useful metadata to have in the future.\n *\n * We also need to handle cases in which the SDK is used in a child browsing context (e.g. an iframe), which may not\n * have a hostname – in this case we'll check each ancestor context until we find a valid hostname.\n */\nfunction parseApplicationOrigin(): string {\n    let origin = location.hostname;\n    // Firefox does not implement ancestorOrigins, so we need a fallback.\n    // Context here: https://github.com/whatwg/html/issues/1918\n    const ancestorOrigins =\n        location.ancestorOrigins === undefined\n            ? typeof window !== \"undefined\"\n                ? [window.parent.origin, window.top?.origin ?? \"\"]\n                : []\n            : Array.from(location.ancestorOrigins ?? []);\n\n    while (origin === \"\" && ancestorOrigins.length > 0) {\n        // Safety: ancestorOrigins must contain at least one element, so shift() will always be defined.\n        origin = new URL(ancestorOrigins.shift()!).hostname;\n    }\n    return origin;\n}\n\nfunction getCameraKitUserAgent(): CameraKitUserAgent {\n    const userAgent = navigator.userAgent ?? \"\";\n    // [NavigatorUAData](https://developer.mozilla.org/en-US/docs/Web/API/NavigatorUAData) is currently only\n    // available on Chromium-based browsers – it's nice because it gives us clear, well-documented information. But\n    // we'll have to fallback to parsing the userAgent string when it's not available.\n    const userAgentData = isNavigatorUAData(navigator.userAgentData)\n        ? normalizeUserAgentData(navigator.userAgentData)\n        : parseUserAgentData(userAgent);\n\n    const platformVersion = parsePlatformVersion(userAgent);\n    const deviceModel = parseDeviceModel(userAgent);\n\n    // In cases where we've parsed the userAgent string to find the brand, there will only ever be a single brand –\n    // in browsers which support NavigatorUAData there could be more than one (e.g. Chrome and Chromium), but they\n    // should be equivalent for our purposes.\n    const browser = userAgentData.brands[0];\n    const origin = parseApplicationOrigin();\n\n    const sdkLongVersion = environment.PACKAGE_VERSION;\n    // Remove any `-prerelease` or `+buildmetadata` portions from the semver string.\n    const sdkShortVersion = sdkLongVersion.replace(/[-+]\\S+$/, \"\");\n\n    // Set this to `debug` manually while testing / root-causing.\n    const flavor: \"release\" | \"debug\" = \"release\";\n\n    // This full string is defined here:\n    // eslint-disable-next-line max-len\n    // https://github.sc-corp.net/Snapchat/useragent/blob/9333afe7cc6ac00503ad46cb234bcf94006dff98/java/useragent/src/main/java/snapchat/client/UserAgent.java#L124\n    const cameraKitUserAgent =\n        `CameraKitWeb/${sdkShortVersion} ` +\n        `${flavor === \"release\" ? \"\" : \"DEBUG\"}` +\n        `(${deviceModel}; ${userAgentData.platform} ${platformVersion}) ` +\n        `${browser.brand}/${browser.version} ` +\n        `Core/${lensCoreWasm.version} ` +\n        // We overload appId, using the origin instead of the true appId parsed from the apiToken -- we do this because\n        // origin is human-readable, and this is used to populate the appId dimension in operational metrics.\n        `AppId/${origin}`;\n\n    return {\n        osType: userAgentData.platform,\n        osVersion: platformVersion,\n        locale,\n        sdkShortVersion,\n        sdkLongVersion,\n        flavor,\n        lensCoreVersion: `${lensCoreWasm.version}`,\n        deviceModel,\n        browser,\n        origin,\n        userAgent: cameraKitUserAgent,\n    };\n}\n\n/** @internal */\nexport interface CameraKitUserAgent {\n    osType: string;\n    osVersion: string;\n    locale: string;\n    sdkShortVersion: string;\n    sdkLongVersion: string;\n    flavor: \"release\" | \"debug\";\n    lensCoreVersion: string;\n    deviceModel: string;\n    browser: { brand: string; version: string };\n    origin: string;\n    userAgent: string;\n}\n\n/** @internal */\nexport const cameraKitUserAgent = getCameraKitUserAgent();\n"]}