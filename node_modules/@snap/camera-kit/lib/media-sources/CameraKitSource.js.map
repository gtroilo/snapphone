{"version":3,"file":"CameraKitSource.js","sourceRoot":"","sources":["../../src/media-sources/CameraKitSource.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/member-ordering */\n\nimport { validate } from \"../common/validate\";\nimport { LensCoreModule, UseMediaElementInput } from \"../lens-core-module/generated-types\";\nimport { Transform2D } from \"../transforms\";\n\nconst defaultDeviceInfo: CameraKitDeviceInfo = {\n    cameraType: \"front\",\n    fpsLimit: Number.POSITIVE_INFINITY,\n};\n\nconst createNotAttachedError = (message: string) =>\n    new Error(`${message}. This CameraKitSource is not attached to a CameraKitSession.`);\n\n/**\n * When creating a {@link CameraKitSource}, passing a CameraKitSourceSubscriber allows logic to implemented which will\n * run whenever that source is attached/detached from a CameraKitSession.\n *\n * @category Rendering\n */\nexport interface CameraKitSourceSubscriber {\n    readonly onAttach?: (\n        source: CameraKitSource,\n        lensCore: LensCoreModule,\n        reportError: (error: Error) => void\n    ) => void | Promise<void>;\n    readonly onDetach?: (reportError: (error: Error) => void) => void | Promise<void>;\n}\n\n/** @category Rendering */\nexport type CameraKitDeviceInfo = {\n    cameraType: \"front\" | \"back\";\n    fpsLimit: number;\n};\n\nexport type CameraKitSourceInfo = Pick<\n    UseMediaElementInput,\n    \"media\" | \"replayTrackingData\" | \"useManualFrameProcessing\"\n>;\n\n/** @category Rendering */\nexport type CameraKitSourceOptions<T = {}> = Partial<T> & Partial<CameraKitDeviceInfo>;\n\n/**\n * This general-purpose class represents a source of media for a {@link CameraKitSession}.\n *\n * When an instance is passed to {@link CameraKitSession.setSource | CameraKitSession.setSource}, it will be \"attached\"\n * to the session. Later it may be \"detached\" from the session.\n *\n * Passing a {@link CameraKitSourceSubscriber} to the constructor allows callers to specify behavior\n * that will occur when the source is attached and detached. This can be used to e.g. update the render size.\n *\n * @category Rendering\n */\nexport class CameraKitSource {\n    private lensCore?: LensCoreModule;\n    private readonly deviceInfo: CameraKitDeviceInfo;\n\n    constructor(\n        private readonly sourceInfo: CameraKitSourceInfo,\n        private readonly subscriber: CameraKitSourceSubscriber = {},\n        deviceInfo: Partial<CameraKitDeviceInfo> = {}\n    ) {\n        this.deviceInfo = { ...defaultDeviceInfo, ...deviceInfo };\n    }\n\n    /**\n     * Called by {@link CameraKitSession} when this source is set as that session's source.\n     *\n     * @param lensCore\n     * @param reportError Calling this function will report an error back to the session.\n     * @returns Rejects if any calls to LensCore or CameraKitSource.subscriber.onAttach fail.\n     * @internal\n     */\n    async attach(lensCore: LensCoreModule, reportError: (error: Error) => void): Promise<void> {\n        if (this.lensCore) {\n            throw new Error(\n                \"Cannot attach. This CameraKitCustomSource has already been attached to \" +\n                    \"a CameraKitSession. To re-attach, create a copy of this CameraKitCustomSource.\"\n            );\n        }\n\n        this.lensCore = lensCore;\n\n        await new Promise((onSuccess, onFailure) => {\n            lensCore.useMediaElement({\n                autoplayNewMedia: false,\n                autoplayPreviewCanvas: false,\n                media: this.sourceInfo.media,\n                pauseExistingMedia: false,\n                replayTrackingData: this.sourceInfo.replayTrackingData,\n                requestWebcam: false,\n                startOnFrontCamera: this.deviceInfo.cameraType === \"front\",\n                useManualFrameProcessing: this.sourceInfo.useManualFrameProcessing,\n                onSuccess,\n                onFailure,\n            });\n        });\n\n        await new Promise<void>((onSuccess, onFailure) => {\n            // LensCore uses 0 to remove the limit.\n            const fps = this.deviceInfo.fpsLimit < Number.POSITIVE_INFINITY ? this.deviceInfo.fpsLimit : 0;\n            lensCore.setFPSLimit({ fps, onSuccess, onFailure });\n        });\n\n        if (this.subscriber.onAttach) await this.subscriber.onAttach(this, lensCore, reportError);\n    }\n\n    /**\n     * Make a copy of the source, sharing the same {@link CameraKitSourceSubscriber}.\n     *\n     * @param deviceInfo Optionally provide new device info for the copy (e.g. to change the camera type).\n     * @returns The new {@link CameraKitSource}\n     */\n    copy(deviceInfo: Partial<CameraKitDeviceInfo> = {}): CameraKitSource {\n        return new CameraKitSource(this.sourceInfo, this.subscriber, { ...this.deviceInfo, ...deviceInfo });\n    }\n\n    /**\n     * Called by {@link CameraKitSession} when it must remove this source.\n     *\n     * @param reportError Calling this function will report an error back to the session.\n     * @returns\n     * @internal\n     */\n    detach(reportError: (error: Error) => void): void | Promise<void> {\n        if (!this.lensCore) return Promise.reject(createNotAttachedError(\"Cannot detach\"));\n        if (this.subscriber.onDetach) return this.subscriber.onDetach(reportError);\n    }\n\n    /**\n     * Set the resolution used to render this source.\n     *\n     * Itâ€™s important to distinguish render size from display size. The size at which the output canvases are displayed\n     * on a web page is determined by the CSS of the page. It is distinct from the size at which LensCore renders\n     * Lenses. Performance is dominated by render size, while any display scaling can most often be thought of as free.\n     *\n     * If greater performance is required, a smaller render size may boost frame-rate. It does come at a cost, including\n     * loss of accuracy in various tracking and computer-vision algorithms (since they'll be operating on fewer pixels).\n     *\n     * The size of the Live and Capture {@link RenderTarget} is always the same.\n     *\n     * @todo Currently it's only valid to call `setRenderSize` after `CameraKitSession.play` has been called. This\n     * constraint should be removed, so callers don't have to understand the underlying LensCore state machine.\n     *\n     * @param width pixels\n     * @param height pixels\n     * @returns Promise resolves when the render size has been successfully updated.\n     */\n    @validate\n    setRenderSize(width: number, height: number): Promise<void> {\n        return new Promise((onSuccess, onFailure) => {\n            if (!this.lensCore) return onFailure(createNotAttachedError(\"Cannot setRenderSize\"));\n            const target = { width, height };\n            this.lensCore.setRenderSize({ mode: \"explicit\", target, onSuccess, onFailure });\n        });\n    }\n\n    /**\n     * Apply a 2D transformation to the source (e.g. translation, rotation, scale).\n     *\n     * @param transform Specifies the 3x3 matrix describing the transformation.\n     */\n    @validate\n    setTransform(transform: Transform2D): Promise<void> {\n        return new Promise((onSuccess, onFailure) => {\n            if (!this.lensCore) return onFailure(createNotAttachedError(\"Cannot setTransform\"));\n            const matrix = new Float32Array(transform.matrix);\n            this.lensCore.setInputTransform({ matrix, onSuccess, onFailure });\n        });\n    }\n}\n"]}